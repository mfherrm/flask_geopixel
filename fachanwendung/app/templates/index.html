<!DOCTYPE html>
<html lang="en">

<head>
    <base target="_top">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Geopixel implemented into disy Cadenza">
    <meta name="theme-color" content="#ffffff">
    <!-- CSP temporarily disabled for RunPod testing -->
    <!-- <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; script-src 'self' 'unsafe-inline' https://ajax.googleapis.com https://cdn.jsdelivr.net https://html2canvas.hertzen.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https://mt0.google.com https://mt1.google.com https://mt2.google.com https://mt3.google.com; frame-src 'self' http://localhost:8080; connect-src 'self' http://localhost:8080 http://127.0.0.1:5000 https://api.runpod.ai;"> -->

    <title>GeoPixel for disy Cadenza</title>

    <!-- Preload critical resources -->
    <link rel="preload" href="../static/css/style.css?v=2025061001" as="style">

    <!-- Stylesheets -->
    <link rel="stylesheet" href="../static/css/style.css?v=2025061001">
    <link rel="stylesheet" href="../static/js/ol/ol.css">
    
</head>

<body data-cadenza-uri="{{ cadenza_uri }}" data-cadenza-repository-name="{{ config.CADENZA_REPOSITORY_NAME }}"
    data-cadenza-external-link-id="{{ config.CADENZA_EXTERNAL_LINK_ID }}">
    <div id="cadenza-container">
        <!-- Both elements visible initially to allow proper initialization -->

        <div id="OL-map" class="olmap" style="width: 95%; height: 95vh; display: block;"></div>
        <iframe id="cadenza-iframe" style="height: 95vh; width: 95%; display: block;"></iframe>
        
        <!-- Control buttons positioned right below the map -->
        <div id="button-container">
            <button id="screenMap" disabled>Call GeoPixel</button>
            <!-- First Dropup Button -->
            <div class="dropup">
                <button id="colorbttn" class="dropbtn">Color</button>
                <div class="dropup-content">
                    <!-- Primary Colors -->
                    <a href="#" class="color-option">Red</a>
                    <a href="#" class="color-option">Green</a>
                    <a href="#" class="color-option">Blue</a>
                    <a href="#" class="color-option">Yellow</a>
                    <a href="#" class="color-option">Orange</a>
                    <a href="#" class="color-option">Purple</a>
                    <a href="#" class="color-option">Pink</a>
                    <a href="#" class="color-option">Cyan</a>
                    <a href="#" class="color-option">Magenta</a>
                    <!-- Grayscale Options -->
                    <a href="#" class="color-option">Black</a>
                    <a href="#" class="color-option">White</a>
                    <a href="#" class="color-option">Grey</a>
                    <a href="#" class="color-option">Dark Grey</a>
                    <a href="#" class="color-option">Light Grey</a>
                    <!-- Earth Tones -->
                    <a href="#" class="color-option">Brown</a>
                    <a href="#" class="color-option">Tan</a>
                    <a href="#" class="color-option">Beige</a>
                    <a href="#" class="color-option">Khaki</a>
                    <!-- Scientific Spectral -->
                    <a href="#" class="color-option">Infrared</a>
                    <a href="#" class="color-option">Near-Infrared</a>
                    <a href="#" class="color-option">Thermal</a>
                    <a href="#" class="color-option">Multispectral</a>
                    <!-- Vegetation Indices -->
                    <a href="#" class="color-option">NDVI Green</a>
                    <a href="#" class="color-option">Chlorophyll</a>
                    <a href="#" class="color-option">Vegetation Red</a>
                    <!-- Water Colors -->
                    <a href="#" class="color-option">Deep Blue</a>
                    <a href="#" class="color-option">Aqua</a>
                    <a href="#" class="color-option">Turquoise</a>
                    <a href="#" class="color-option">Navy</a>
                </div>
            </div>

            <!-- Second Dropup Button -->
            <div class="dropup">
                <button id="objbttn" class="dropbtn">Object</button>
                <div class="dropup-content">
                    <!-- Transportation -->
                    <a href="#" class="object-option">Car</a>
                    <a href="#" class="object-option">Truck</a>
                    <a href="#" class="object-option">Bus</a>
                    <a href="#" class="object-option">Motorcycle</a>
                    <a href="#" class="object-option">Bicycle</a>
                    <a href="#" class="object-option">Train</a>
                    <a href="#" class="object-option">Aircraft</a>
                    <a href="#" class="object-option">Ship</a>
                    <a href="#" class="object-option">Boat</a>
                    <!-- Infrastructure -->
                    <a href="#" class="object-option">Building</a>
                    <a href="#" class="object-option">House</a>
                    <a href="#" class="object-option">Skyscraper</a>
                    <a href="#" class="object-option">Factory</a>
                    <a href="#" class="object-option">Warehouse</a>
                    <a href="#" class="object-option">School</a>
                    <a href="#" class="object-option">Hospital</a>
                    <a href="#" class="object-option">Bridge</a>
                    <a href="#" class="object-option">Road</a>
                    <a href="#" class="object-option">Highway</a>
                    <a href="#" class="object-option">Runway</a>
                    <a href="#" class="object-option">Parking Lot</a>
                    <a href="#" class="object-option">Solar Panel</a>
                    <a href="#" class="object-option">Wind Turbine</a>
                    <!-- Natural Features -->
                    <a href="#" class="object-option">River</a>
                    <a href="#" class="object-option">Lake</a>
                    <a href="#" class="object-option">Ocean</a>
                    <a href="#" class="object-option">Stream</a>
                    <a href="#" class="object-option">Pond</a>
                    <a href="#" class="object-option">Wetland</a>
                    <a href="#" class="object-option">Mountain</a>
                    <a href="#" class="object-option">Hill</a>
                    <a href="#" class="object-option">Valley</a>
                    <a href="#" class="object-option">Canyon</a>
                    <a href="#" class="object-option">Beach</a>
                    <a href="#" class="object-option">Coastline</a>
                    <a href="#" class="object-option">Island</a>
                    <!-- Vegetation -->
                    <a href="#" class="object-option">Forest</a>
                    <a href="#" class="object-option">Tree</a>
                    <a href="#" class="object-option">Grass</a>
                    <a href="#" class="object-option">Crop Field</a>
                    <a href="#" class="object-option">Farmland</a>
                    <a href="#" class="object-option">Orchard</a>
                    <a href="#" class="object-option">Vineyard</a>
                    <a href="#" class="object-option">Park</a>
                    <a href="#" class="object-option">Garden</a>
                    <a href="#" class="object-option">Shrub</a>
                    <a href="#" class="object-option">Pasture</a>
                    <!-- Urban Features -->
                    <a href="#" class="object-option">Urban Area</a>
                    <a href="#" class="object-option">Residential</a>
                    <a href="#" class="object-option">Commercial</a>
                    <a href="#" class="object-option">Industrial</a>
                    <a href="#" class="object-option">Construction Site</a>
                    <a href="#" class="object-option">Stadium</a>
                    <a href="#" class="object-option">Sports Field</a>
                    <a href="#" class="object-option">Golf Course</a>
                    <a href="#" class="object-option">Cemetery</a>
                    <!-- Geological -->
                    <a href="#" class="object-option">Rock Formation</a>
                    <a href="#" class="object-option">Sand</a>
                    <a href="#" class="object-option">Desert</a>
                    <a href="#" class="object-option">Quarry</a>
                    <a href="#" class="object-option">Mine</a>
                    <a href="#" class="object-option">Landslide</a>
                    <a href="#" class="object-option">Erosion</a>
                    <!-- Environmental -->
                    <a href="#" class="object-option">Fire</a>
                    <a href="#" class="object-option">Flood</a>
                    <a href="#" class="object-option">Snow</a>
                    <a href="#" class="object-option">Ice</a>
                    <a href="#" class="object-option">Cloud</a>
                    <a href="#" class="object-option">Shadow</a>
                    <a href="#" class="object-option">Smoke</a>
                    <a href="#" class="object-option">Pollution</a>
                    <!-- Agriculture -->
                    <a href="#" class="object-option">Greenhouse</a>
                    <a href="#" class="object-option">Barn</a>
                    <a href="#" class="object-option">Silo</a>
                    <a href="#" class="object-option">Irrigation</a>
                    <a href="#" class="object-option">Livestock</a>
                </div>
            </div>

            <!-- Tile Count Selection -->
            <div class="dropup">
                <button id="tilesbttn" class="dropbtn">Tiles: 1</button>
                <div class="dropup-content">
                    <a href="#" class="tiles-option" data-tiles="1">1 tile (1x1)</a>
                    <a href="#" class="tiles-option" data-tiles="6">6 tiles (2x3)</a>
                    <a href="#" class="tiles-option" data-tiles="12">12 tiles (3x4)</a>
                    <a href="#" class="tiles-option" data-tiles="20">20 tiles (4x5)</a>
                    <a href="#" class="tiles-option" data-tiles="24">24 tiles (4x6)</a>
                    <a href="#" class="tiles-option" data-tiles="30">30 tiles (5x6)</a>
                    <a href="#" class="tiles-option" data-tiles="42">42 tiles (6x7)</a>
                </div>
            </div>

            <!-- Radio buttons next to tiles button -->
            <div class="form-check">
                <input class="form-check-input" type="radio" name="vis" id="olbtn" value="1" checked>
                <label class="form-check-label" for="olbtn">
                    OpenLayers
                </label>
            </div>
            <div class="form-check">
                <input class="form-check-input" type="radio" name="vis" id="cdzbtn" value="2">
                <label class="form-check-label" for="cdzbtn">
                    Cadenza
                </label>
            </div>

            <!-- RunPod Control Button -->
            <button id="runpod-toggle-btn" class="dropbtn">RunPod Control</button>
        </div>

        <!-- RunPod Control Panel (initially hidden) -->
        <div id="runpod-panel" style="background: rgba(255,255,255,0.95); border: 2px solid #007bff; border-radius: 8px; padding: 15px; margin: 20px 0 10px 0; max-width: 800px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); display: none; position: relative; left: 0;">
                    <h4 style="margin: 0 0 15px 0; color: #007bff; font-size: 16px; font-weight: bold;">RunPod Control</h4>
                    
                    <!-- API Key Input -->
            <div style="margin-bottom: 10px;">
                <label for="runpod-api-key" style="display: block; font-size: 12px; margin-bottom: 5px;">API Key:</label>
                <input type="password" id="runpod-api-key" placeholder="Enter RunPod API Key" style="width: 100%; padding: 5px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                <div style="font-size: 10px; color: #666; margin-top: 2px;">
                    Get your API key from RunPod Console → Settings → API Keys
                </div>
            </div>
            
            <!-- Template ID Input -->
            <div style="margin-bottom: 10px;">
                <label for="runpod-template-id" style="display: block; font-size: 12px; margin-bottom: 5px;">Template ID:</label>
                <input type="text" id="runpod-template-id" value="twv5k60kj1" placeholder="e.g., runpod/pytorch:2.0.1-py3.10-cuda11.8.0-devel-ubuntu22.04" style="width: 100%; padding: 5px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                <div style="font-size: 10px; color: #666; margin-top: 2px;">
                    Format: Can be a Docker image (user/image:tag) or RunPod template ID
                </div>
            </div>
            
            <!-- Pod Name Input -->
            <div style="margin-bottom: 15px;">
                <label for="runpod-name" style="display: block; font-size: 12px; margin-bottom: 5px;">Pod Name:</label>
                <input type="text" id="runpod-name" placeholder="Enter Pod Name (optional)" style="width: 100%; padding: 5px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
            </div>
            
            <!-- Control Buttons -->
            <div style="margin-bottom: 15px;">
                <button id="runpod-test" style="background: #17a2b8; color: white; border: none; padding: 6px 12px; border-radius: 4px; margin-right: 5px; cursor: pointer; font-size: 11px;">Test API</button>
                <button id="runpod-start" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; margin-right: 10px; cursor: pointer; font-size: 12px;">Start Pod</button>
                <button id="runpod-stop" style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 12px;" disabled>Stop Pod</button>
            </div>
            
            <!-- Status Display -->
            <div id="runpod-status" style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; font-size: 12px; min-height: 60px;">
                <div style="font-weight: bold; margin-bottom: 5px;">Status: <span id="runpod-status-text">Not Connected</span></div>
                <div id="runpod-details" style="color: #666; font-size: 11px;"></div>
                <div id="runpod-error" style="color: #dc3545; font-size: 11px; margin-top: 5px;"></div>
            </div>
        </div>
    </div>

    <!-- Scripts loaded at the end for better performance -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js"
        integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+"
        crossorigin="anonymous"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <!-- OpenLayers bundled version -->
    <script src="{{ url_for('static', filename='js/ol/dist/ol.js') }}"></script>
    
    <!-- Dropup functionality script -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Handle dropdown button clicks to show/hide content
            document.querySelectorAll('.dropbtn').forEach(button => {
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Close all other dropups first
                    document.querySelectorAll('.dropup-content').forEach(content => {
                        if (content !== this.nextElementSibling) {
                            content.classList.remove('show');
                            content.style.display = 'none';
                        }
                    });
                    
                    // Toggle the clicked dropup
                    const dropupContent = this.nextElementSibling;
                    if (dropupContent) {
                        const isCurrentlyVisible = dropupContent.style.display === 'block';
                        if (isCurrentlyVisible) {
                            dropupContent.style.display = 'none';
                            dropupContent.classList.remove('show');
                        } else {
                            dropupContent.style.display = 'block';
                            dropupContent.classList.add('show');
                        }
                    }
                });
            });
            
            // Close dropups when clicking outside
            document.addEventListener('click', function(e) {
                // Check if the click is outside any dropup container
                const clickedInsideDropup = e.target.closest('.dropup');
                if (!clickedInsideDropup) {
                    document.querySelectorAll('.dropup-content').forEach(content => {
                        content.classList.remove('show');
                        content.style.display = 'none';
                    });
                }
            });
            
            // Handle option selections
            document.querySelectorAll('.tiles-option').forEach(option => {
                option.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const tileCount = parseInt(this.dataset.tiles);
                    document.getElementById('tilesbttn').textContent = `Tiles: ${tileCount}`;
                    const dropupContent = this.closest('.dropup-content');
                    dropupContent.classList.remove('show');
                    dropupContent.style.display = 'none';
                    
                    // Update tile configuration if function is available
                    if (window.updateTileConfig) {
                        window.updateTileConfig(tileCount);
                    }
                });
            });
            
            document.querySelectorAll('.color-option').forEach(option => {
                option.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    document.getElementById('colorbttn').textContent = this.textContent;
                    const dropupContent = this.closest('.dropup-content');
                    dropupContent.classList.remove('show');
                    dropupContent.style.display = 'none';
                });
            });
            
            document.querySelectorAll('.object-option').forEach(option => {
                option.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    document.getElementById('objbttn').textContent = this.textContent;
                    const dropupContent = this.closest('.dropup-content');
                    dropupContent.classList.remove('show');
                    dropupContent.style.display = 'none';
                });
            });

            // Handle RunPod Control button toggle
            document.getElementById('runpod-toggle-btn').addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const runpodPanel = document.getElementById('runpod-panel');
                const runpodButton = document.getElementById('runpod-toggle-btn');
                const isCurrentlyVisible = runpodPanel.style.display !== 'none';
                
                if (isCurrentlyVisible) {
                    runpodPanel.style.display = 'none';
                    document.getElementById('cadenza-container').classList.remove('runpod-panel-visible');
                } else {
                    // Position the panel to align borders with the button
                    const buttonRect = runpodButton.getBoundingClientRect();
                    const containerRect = document.getElementById('button-container').getBoundingClientRect();
                    
                    // Account for button border and padding to align the blue borders
                    const buttonStyle = window.getComputedStyle(runpodButton);
                    const buttonBorderLeft = parseInt(buttonStyle.borderLeftWidth) || 0;
                    const buttonPaddingLeft = parseInt(buttonStyle.paddingLeft) || 0;
                    
                    // Calculate offset to align the blue borders
                    const leftOffset = buttonRect.left - containerRect.left - buttonBorderLeft;
                    
                    runpodPanel.style.display = 'block';
                    runpodPanel.style.marginLeft = leftOffset + 'px';
                    runpodPanel.style.marginRight = 'auto';
                    runpodPanel.style.marginBottom = '15px'; // Add reduced bottom margin
                    document.getElementById('cadenza-container').classList.add('runpod-panel-visible');
                    
                    // Scroll to the RunPod Control Panel smoothly
                    setTimeout(() => {
                        runpodPanel.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start',
                            inline: 'nearest'
                        });
                    }, 100); // Small delay to ensure panel is visible before scrolling
                }
            });
        });
    </script>

    <!-- RunPod API Integration Script - Updated 2025-06-10-11:44 -->
    <script>
        class RunPodManager {
            constructor() {
                this.currentPodId = null;
                this.statusCheckInterval = null;
                this.apiBaseUrl = '/runpod-proxy';
                this.initializeEventListeners();
                this.loadSavedCredentials();
                this.setInitialButtonStates();
                this.checkInitialPodStatus();
            }

            initializeEventListeners() {
                document.getElementById('runpod-test').addEventListener('click', () => this.testConnection());
                document.getElementById('runpod-start').addEventListener('click', () => this.startPod());
                document.getElementById('runpod-stop').addEventListener('click', () => this.stopPod());
                
                // Save credentials when they change and check pod status
                document.getElementById('runpod-api-key').addEventListener('change', () => {
                    this.saveCredentials();
                    this.checkPodStatusOnChange();
                });
                document.getElementById('runpod-template-id').addEventListener('change', () => {
                    this.saveCredentials();
                    this.checkPodStatusOnChange();
                });
            }

            loadSavedCredentials() {
                const apiKey = localStorage.getItem('runpod-api-key');
                const templateId = localStorage.getItem('runpod-template-id');
                
                if (apiKey) document.getElementById('runpod-api-key').value = apiKey;
                if (templateId) document.getElementById('runpod-template-id').value = templateId;
            }

            saveCredentials() {
                const apiKey = document.getElementById('runpod-api-key').value;
                const templateId = document.getElementById('runpod-template-id').value;
                
                if (apiKey) localStorage.setItem('runpod-api-key', apiKey);
                if (templateId) localStorage.setItem('runpod-template-id', templateId);
            }

            setInitialButtonStates() {
                console.log('Setting initial button states...');
                
                // Set initial button states before any pod status checks
                const startBtn = document.getElementById('runpod-start');
                const stopBtn = document.getElementById('runpod-stop');
                const callGeoPixelBtn = document.getElementById('screenMap');
                
                console.log('Button elements found:', {
                    startBtn: !!startBtn,
                    stopBtn: !!stopBtn,
                    callGeoPixelBtn: !!callGeoPixelBtn
                });
                
                if (startBtn && stopBtn && callGeoPixelBtn) {
                    // FORCE correct initial state: Start enabled, Stop disabled, Call GeoPixel disabled
                    console.log('Forcing correct initial button states...');
                    
                    // Start button should be ENABLED initially (no pod running)
                    startBtn.disabled = false;
                    startBtn.style.opacity = '';
                    startBtn.style.cursor = '';
                    
                    // Stop button should be DISABLED initially (no pod running)
                    stopBtn.disabled = true;
                    stopBtn.style.opacity = '';
                    stopBtn.style.cursor = '';
                    
                    // Call GeoPixel button MUST be disabled initially and stay disabled until RunPod status is confirmed
                    console.log('Before setting Call GeoPixel disabled state:', {
                        disabled: callGeoPixelBtn.disabled,
                        className: callGeoPixelBtn.className
                    });
                    
                    // Force disabled state with stronger enforcement
                    callGeoPixelBtn.disabled = true;
                    callGeoPixelBtn.classList.remove('enabled');
                    callGeoPixelBtn.classList.add('disabled-button');
                    
                    // Add a flag to prevent premature enabling
                    callGeoPixelBtn.setAttribute('data-initialization-complete', 'false');
                    
                    console.log('After setting Call GeoPixel disabled state:', {
                        disabled: callGeoPixelBtn.disabled,
                        className: callGeoPixelBtn.className
                    });
                    
                    console.log('CORRECTED initial button states set:', {
                        startBtn_disabled: startBtn.disabled,
                        stopBtn_disabled: stopBtn.disabled,
                        callGeoPixelBtn_disabled: callGeoPixelBtn.disabled,
                        callGeoPixelBtn_classes: callGeoPixelBtn.className
                    });
                } else {
                    console.error('Some button elements not found during initialization');
                }
                
                // Set initial status - DO NOT call updateCallGeoPixelButtonState here as it might enable the button
                this.updateStatus('Not Connected', 'Enter API key and template ID to check pod status');
            }


            updateStatus(status, details = '', error = '') {
                document.getElementById('runpod-status-text').textContent = status;
                document.getElementById('runpod-details').textContent = details;
                document.getElementById('runpod-error').textContent = error;
                
                // Update status styling
                const statusDiv = document.getElementById('runpod-status');
                statusDiv.className = ''; // Clear existing classes
                
                if (status.toLowerCase().includes('running') || status === 'RUNNING') {
                    statusDiv.classList.add('status-running');
                } else if (status.toLowerCase().includes('error') || error) {
                    statusDiv.classList.add('status-error');
                } else if (status.toLowerCase().includes('starting') || status === 'STARTING') {
                    statusDiv.classList.add('status-starting');
                }
                
                // Update button states
                const startBtn = document.getElementById('runpod-start');
                const stopBtn = document.getElementById('runpod-stop');
                
                // Only enable stop button when pod is actually running, not during intermediate states
                if (status === 'RUNNING' || status.toLowerCase().includes('running')) {
                    if (startBtn) {
                        startBtn.disabled = true;
                        startBtn.style.opacity = '';
                        startBtn.style.cursor = '';
                    }
                    if (stopBtn) {
                        stopBtn.disabled = false;
                        stopBtn.style.opacity = '';
                        stopBtn.style.cursor = '';
                    }
                } else if (status === 'Starting' || status === 'Starting...' || status === 'STARTING' ||
                          status === 'Checking...' || status === 'Already Running') {
                    // During pod creation process: keep start button disabled, keep stop button disabled
                    if (startBtn) {
                        startBtn.disabled = true;
                    }
                    if (stopBtn) {
                        stopBtn.disabled = true;
                    }
                } else {
                    // For other states (Error, Stopped, Not Connected, etc.): enable start, disable stop
                    if (startBtn) {
                        startBtn.disabled = false;
                        // Clear any manual styling that was applied during operations
                        startBtn.style.opacity = '';
                        startBtn.style.cursor = '';
                    }
                    if (stopBtn) {
                        stopBtn.disabled = true;
                        // Clear any manual styling that was applied during operations
                        stopBtn.style.opacity = '';
                        stopBtn.style.cursor = '';
                    }
                }
                
                // Always update Call GeoPixel button state, but respect initialization flag
                console.log('Updating Call GeoPixel button state after status update...');
                this.updateCallGeoPixelButtonState();
            }

            async checkInitialPodStatus() {
                // Check if there's already a pod running with the current template on page load
                const templateId = document.getElementById('runpod-template-id').value.trim();
                const apiKey = document.getElementById('runpod-api-key').value.trim();
                
                // ALWAYS ensure ALL buttons are in correct initial state
                console.log('Setting all buttons to correct initial state...');
                const callGeoPixelBtn = document.getElementById('screenMap');
                const startBtn = document.getElementById('runpod-start');
                const stopBtn = document.getElementById('runpod-stop');
                
                // Force correct initial button states regardless of any previous state
                if (callGeoPixelBtn) {
                    callGeoPixelBtn.disabled = true;
                    callGeoPixelBtn.classList.remove('enabled');
                    callGeoPixelBtn.classList.add('disabled-button');
                }
                
                if (startBtn) {
                    startBtn.disabled = false; // Start button should be enabled initially
                    startBtn.style.opacity = '';
                    startBtn.style.cursor = '';
                }
                
                if (stopBtn) {
                    stopBtn.disabled = true; // Stop button should be disabled initially
                    stopBtn.style.opacity = '';
                    stopBtn.style.cursor = '';
                }
                
                if (templateId && apiKey) {
                    console.log('Checking initial pod status...');
                    await this.checkPodStatusWithTemplate(templateId, apiKey);
                } else {
                    // If no API key or template ID, ensure buttons are in disabled state and mark initialization complete
                    console.log('No API key or template ID found, setting correct initial button states');
                    this.updateStatus('Not Connected', 'Enter API key and template ID to check pod status');
                    
                    // Mark initialization as complete even when no credentials are provided
                    if (callGeoPixelBtn) {
                        callGeoPixelBtn.setAttribute('data-initialization-complete', 'true');
                        console.log('No credentials provided but initialization flag set to true');
                    }
                }
            }

            async checkPodStatusWithTemplate(templateId, apiKey) {
                try {
                    const response = await fetch('/check-pod-status', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            api_key: apiKey,
                            template_id: templateId
                        })
                    });

                    const data = await response.json();
                    
                    // Mark initialization as complete after first status check
                    const callGeoPixelBtn = document.getElementById('screenMap');
                    if (callGeoPixelBtn) {
                        callGeoPixelBtn.setAttribute('data-initialization-complete', 'true');
                        console.log('RunPod status check complete - initialization flag set to true');
                    }
                    
                    if (data.success && data.pod_running) {
                        // Pod is already running with this template
                        this.currentPodId = data.pod_id;
                        this.updateStatus('RUNNING', `Pod: ${data.pod_name || data.pod_id}\nEndpoint: ${data.endpoint_url || 'Not available'}`);
                        this.startStatusChecking();
                        console.log(`Found running pod with template ${templateId}: ${data.pod_id}`);
                    } else if (data.success && !data.pod_running) {
                        // No pod running with this template - explicitly update button state
                        this.updateStatus('Not Running', 'No pod found with this template');
                        console.log(`No running pod found with template ${templateId} - ensuring Call GeoPixel button is disabled`);
                        
                        // FORCE Call GeoPixel button to be disabled since no pod is running
                        const callGeoPixelBtn = document.getElementById('screenMap');
                        if (callGeoPixelBtn) {
                            callGeoPixelBtn.disabled = true;
                            callGeoPixelBtn.classList.remove('enabled');
                            callGeoPixelBtn.classList.add('disabled-button');
                            console.log('FORCED Call GeoPixel button disabled - no pod running');
                        }
                    } else {
                        console.error('Error checking pod status:', data.error);
                        // On error, ensure button is disabled
                        this.updateStatus('Error', 'Failed to check pod status');
                        
                        // FORCE Call GeoPixel button to be disabled on error
                        const callGeoPixelBtn = document.getElementById('screenMap');
                        if (callGeoPixelBtn) {
                            callGeoPixelBtn.disabled = true;
                            callGeoPixelBtn.classList.remove('enabled');
                            callGeoPixelBtn.classList.add('disabled-button');
                            console.log('FORCED Call GeoPixel button disabled - error occurred');
                        }
                    }
                } catch (error) {
                    console.error('Failed to check pod status:', error);
                    // Mark initialization as complete even on error to prevent permanent disabled state
                    const callGeoPixelBtn = document.getElementById('screenMap');
                    if (callGeoPixelBtn) {
                        callGeoPixelBtn.setAttribute('data-initialization-complete', 'true');
                        console.log('RunPod status check failed but initialization flag set to true to prevent permanent disabled state');
                    }
                    this.updateStatus('Error', 'Failed to check pod status');
                    this.updateCallGeoPixelButtonState();
                }
            }

            updateCallGeoPixelButtonState() {
                console.log('Updating Call GeoPixel button state...');
                
                const callGeoPixelButton = document.getElementById('screenMap');
                const statusText = document.getElementById('runpod-status-text').textContent;
                
                // Check if initialization is complete
                const initializationComplete = callGeoPixelButton?.getAttribute('data-initialization-complete') === 'true';
                
                // Check if OpenLayers is currently visible (not Cadenza)
                const openLayersRadio = document.getElementById('olbtn');
                const isOpenLayersMode = openLayersRadio && openLayersRadio.checked;
                
                console.log('Button state check:', {
                    statusText: statusText,
                    isOpenLayersMode: isOpenLayersMode,
                    callGeoPixelButton: !!callGeoPixelButton,
                    initializationComplete: initializationComplete
                });
                
                if (!callGeoPixelButton) {
                    console.error('Call GeoPixel button not found!');
                    return;
                }
                
                // If initialization is not complete, keep button disabled regardless of other conditions
                if (!initializationComplete) {
                    console.log('Initialization not complete - keeping Call GeoPixel button disabled');
                    callGeoPixelButton.disabled = true;
                    callGeoPixelButton.classList.remove('enabled');
                    callGeoPixelButton.classList.add('disabled-button');
                    return;
                }
                
                console.log('Before update:', {
                    disabled: callGeoPixelButton.disabled,
                    className: callGeoPixelButton.className,
                    style: callGeoPixelButton.style.cssText
                });
                
                if (!isOpenLayersMode) {
                    // Cadenza is visible - disable button regardless of pod status
                    console.log('Cadenza mode - disabling Call GeoPixel button');
                    callGeoPixelButton.disabled = true;
                    callGeoPixelButton.classList.remove('enabled');
                    callGeoPixelButton.classList.add('disabled-button');
                    return;
                }
                
                // OpenLayers is visible - check pod status
                if (statusText === 'RUNNING' || statusText.toLowerCase().includes('running')) {
                    // Pod is running and OpenLayers is visible - enable Call GeoPixel button
                    console.log('Pod running and OpenLayers mode - enabling Call GeoPixel button');
                    callGeoPixelButton.disabled = false;
                    callGeoPixelButton.classList.add('enabled');
                    callGeoPixelButton.classList.remove('disabled-button');
                } else {
                    // No pod running - disable Call GeoPixel button
                    console.log(`No pod running (status: "${statusText}") - disabling Call GeoPixel button`);
                    callGeoPixelButton.disabled = true;
                    callGeoPixelButton.classList.remove('enabled');
                    callGeoPixelButton.classList.add('disabled-button');
                    
                    // Extra logging for debugging
                    console.log('Call GeoPixel button FORCED to disabled state:', {
                        disabled: callGeoPixelButton.disabled,
                        className: callGeoPixelButton.className,
                        statusText: statusText
                    });
                }
                
                console.log('After update:', {
                    disabled: callGeoPixelButton.disabled,
                    className: callGeoPixelButton.className,
                    style: callGeoPixelButton.style.cssText
                });
            }

            async checkPodStatusOnChange() {
                // Check pod status when template ID or API key changes
                const templateId = document.getElementById('runpod-template-id').value.trim();
                const apiKey = document.getElementById('runpod-api-key').value.trim();
                
                if (templateId && apiKey) {
                    console.log('Template or API key changed, checking pod status...');
                    await this.checkPodStatusWithTemplate(templateId, apiKey);
                } else {
                    // Reset status if either field is empty and ensure buttons are disabled
                    this.updateStatus('Not Connected', 'Enter API key and template ID');
                    this.currentPodId = null;
                    this.stopStatusChecking();
                    
                    // Mark initialization as complete even when credentials are missing
                    const callGeoPixelBtn = document.getElementById('screenMap');
                    if (callGeoPixelBtn) {
                        callGeoPixelBtn.setAttribute('data-initialization-complete', 'true');
                        console.log('Credentials missing but initialization flag set to true');
                        
                        // Explicitly disable Call GeoPixel button when credentials are missing
                        callGeoPixelBtn.disabled = true;
                        callGeoPixelBtn.classList.remove('enabled');
                        callGeoPixelBtn.classList.add('disabled-button');
                    }
                }
            }

            async makeGraphQLRequest(query, variables = {}) {
                const apiKey = document.getElementById('runpod-api-key').value;
                
                if (!apiKey) {
                    throw new Error('API Key is required');
                }

                try {
                    console.log('Making request to RunPod Proxy:', this.apiBaseUrl);
                    
                    const response = await fetch(this.apiBaseUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            api_key: apiKey,
                            query: query,
                            variables: variables
                        })
                    });

                    console.log('Response status:', response.status);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                    }

                    const data = await response.json();
                    console.log('Response data:', data);
                    
                    if (data.errors) {
                        throw new Error(data.errors[0].message);
                    }
                    
                    return data.data;
                } catch (error) {
                    console.error('GraphQL request failed:', error);
                    if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        throw new Error('Network error: Unable to connect to RunPod API. Check your internet connection and API endpoint.');
                    }
                    throw error;
                }
            }

            async testConnection() {
                try {
                    const apiKey = document.getElementById('runpod-api-key').value.trim();
                    
                    // Validate API key before testing
                    if (!apiKey) {
                        throw new Error('API Key is required for testing');
                    }
                    
                    this.updateStatus('Testing...', 'Checking API connection');
                    
                    // Simple query to test the connection - use RunPod's actual schema
                    const query = `
                        query {
                            myself {
                                id
                                email
                            }
                        }
                    `;
                    
                    const result = await this.makeGraphQLRequest(query);
                    
                    if (result && result.myself) {
                        this.updateStatus('Connected', `API working! User: ${result.myself.email || result.myself.id}`);
                    } else if (result) {
                        this.updateStatus('Connected', 'API connection successful');
                    } else {
                        throw new Error('No valid response from API');
                    }
                    
                } catch (error) {
                    this.updateStatus('Connection Failed', '', `Error: ${error.message}`);
                    console.error('Connection test failed:', error);
                }
            }

            async startPod() {
                try {
                    const apiKey = document.getElementById('runpod-api-key').value.trim();
                    const templateId = document.getElementById('runpod-template-id').value.trim();
                    const podName = document.getElementById('runpod-name').value.trim() || 'GeoPixel-Pod';
                    
                    // Immediately disable the start button when clicked
                    const startBtn = document.getElementById('runpod-start');
                    if (startBtn) {
                        startBtn.disabled = true;
                        startBtn.style.opacity = '0.6';
                        startBtn.style.cursor = 'not-allowed';
                    }
                    
                    // Validate required fields
                    if (!apiKey) {
                        throw new Error('API Key is required');
                    }
                    if (!templateId) {
                        throw new Error('Template ID is required');
                    }
                    if (podName.length === 0) {
                        throw new Error('Pod Name cannot be empty');
                    }

                    // First check if there's already a pod running with this template
                    this.updateStatus('Checking...', 'Checking for existing pods with this template');
                    
                    const existingPodStatus = await this.checkPodStatusWithTemplate(templateId, apiKey);
                    
                    // If a pod is already running, don't start a new one
                    if (this.currentPodId) {
                        this.updateStatus('Already Running', 'Pod with this template is already running');
                        return;
                    }

                    this.updateStatus('Starting...', 'Creating new pod instance');

                    const mutation = `
                        mutation podFindAndDeployOnDemand($input: PodFindAndDeployOnDemandInput) {
                            podFindAndDeployOnDemand(input: $input) {
                                id
                                imageName
                                env
                                machineId
                                machine {
                                    podHostId
                                }
                            }
                        }
                    `;

                    // Ensure all variables are properly formatted and not empty
                    const variables = {
                        input: {
                            cloudType: "ALL",
                            gpuCount: 1,
                            volumeInGb: 0,
                            containerDiskInGb: 60,
                            minVcpuCount: 1,
                            minMemoryInGb: 30,
                            gpuTypeId: "NVIDIA RTX 6000 Ada Generation",
                            name: podName.trim(),
                            templateId: templateId.trim(),
                            dockerArgs: "",
                            ports: "8888/http,5000/http",
                            volumeMountPath: "/workspace",
                            env: [
                                {
                                    key: "JUPYTER_PASSWORD",
                                    value: "geopixel123"
                                }
                            ]
                        }
                    };
                    
                    // Validate that critical fields are not empty after trimming
                    if (!variables.input.name || !variables.input.templateId) {
                        throw new Error('Pod name and template ID cannot be empty');
                    }

                    const result = await this.makeGraphQLRequest(mutation, variables);
                    
                    if (result.podFindAndDeployOnDemand) {
                        this.currentPodId = result.podFindAndDeployOnDemand.id;
                        this.updateStatus('Starting', `Pod ID: ${this.currentPodId}`);
                        this.startStatusChecking();
                    } else {
                        throw new Error('Failed to create pod');
                    }

                } catch (error) {
                    this.updateStatus('Error', '', error.message);
                    console.error('RunPod start error:', error);
                    
                    // Re-enable the start button if there was an error
                    const startBtn = document.getElementById('runpod-start');
                    if (startBtn) {
                        startBtn.disabled = false;
                        startBtn.style.opacity = '';
                        startBtn.style.cursor = '';
                    }
                }
            }

            async stopPod() {
                // Get button references once at the start
                const startBtn = document.getElementById('runpod-start');
                const stopBtn = document.getElementById('runpod-stop');
                
                try {
                    if (!this.currentPodId) {
                        throw new Error('No active pod to stop');
                    }

                    // Immediately disable the stop button when clicked
                    if (stopBtn) {
                        stopBtn.disabled = true;
                        stopBtn.style.opacity = '0.6';
                        stopBtn.style.cursor = 'not-allowed';
                    }

                    this.updateStatus('Stopping...', 'Terminating pod instance');

                    const mutation = `
                        mutation podTerminate($input: PodTerminateInput!) {
                            podTerminate(input: $input)
                        }
                    `;

                    const variables = {
                        input: {
                            podId: this.currentPodId
                        }
                    };

                    await this.makeGraphQLRequest(mutation, variables);
                    
                    this.currentPodId = null;
                    this.stopStatusChecking();
                    this.updateStatus('Stopped', 'Pod terminated successfully');
                    
                    // Clear any manual styling from both buttons after stopping
                    if (startBtn) {
                        startBtn.style.opacity = '';
                        startBtn.style.cursor = '';
                    }
                    if (stopBtn) {
                        stopBtn.style.opacity = '';
                        stopBtn.style.cursor = '';
                    }

                } catch (error) {
                    this.updateStatus('Error', '', error.message);
                    console.error('RunPod stop error:', error);
                    
                    // Clear any manual styling from both buttons on error too
                    if (startBtn) {
                        startBtn.style.opacity = '';
                        startBtn.style.cursor = '';
                    }
                    if (stopBtn) {
                        stopBtn.style.opacity = '';
                        stopBtn.style.cursor = '';
                    }
                }
            }

            async checkPodStatus() {
                try {
                    if (!this.currentPodId) return;

                    const query = `
                        query {
                            myself {
                                pods {
                                    id
                                    name
                                    runtime {
                                        uptimeInSeconds
                                        ports {
                                            ip
                                            isIpPublic
                                            privatePort
                                            publicPort
                                            type
                                        }
                                        gpus {
                                            id
                                            gpuUtilPercent
                                            memoryUtilPercent
                                        }
                                    }
                                    machine {
                                        podHostId
                                    }
                                    desiredStatus
                                    lastStatusChange
                                }
                            }
                        }
                    `;

                    const variables = {};

                    const result = await this.makeGraphQLRequest(query, variables);
                    
                    if (result.myself && result.myself.pods) {
                        // Find our specific pod by ID
                        const pod = result.myself.pods.find(p => p.id === this.currentPodId);
                        
                        if (pod) {
                            const status = pod.desiredStatus;
                            
                            let details = `Pod: ${pod.name || this.currentPodId}`;
                            
                            if (pod.runtime) {
                                const uptime = Math.floor(pod.runtime.uptimeInSeconds / 60);
                                details += `\nUptime: ${uptime} minutes`;
                                
                                if (pod.runtime.ports && pod.runtime.ports.length > 0) {
                                    const port = pod.runtime.ports[0];
                                    if (port.publicPort) {
                                        details += `\nAccess: ${port.ip}:${port.publicPort}`;
                                    }
                                }
                                
                                if (pod.runtime.gpus && pod.runtime.gpus.length > 0) {
                                    const gpu = pod.runtime.gpus[0];
                                    details += `\nGPU: ${gpu.gpuUtilPercent}% util, ${gpu.memoryUtilPercent}% mem`;
                                }
                            }
                            
                            this.updateStatus(status, details);
                            
                            if (status === 'EXITED' || status === 'FAILED') {
                                this.currentPodId = null;
                                this.stopStatusChecking();
                            }
                        } else {
                            // Pod not found, might have been terminated
                            this.updateStatus('Not Found', 'Pod may have been terminated');
                            this.currentPodId = null;
                            this.stopStatusChecking();
                        }
                    }

                } catch (error) {
                    console.error('Status check error:', error);
                    // Don't update status on check errors to avoid spam
                }
            }

            startStatusChecking() {
                this.stopStatusChecking(); // Clear any existing interval
                this.statusCheckInterval = setInterval(() => {
                    this.checkPodStatus();
                }, 10000); // Check every 10 seconds
            }

            stopStatusChecking() {
                if (this.statusCheckInterval) {
                    clearInterval(this.statusCheckInterval);
                    this.statusCheckInterval = null;
                }
            }
        }

        // Initialize RunPod manager when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Add a small delay to ensure all elements are properly rendered
            setTimeout(() => {
                window.runPodManager = new RunPodManager();
                
                // Set up radio button change listeners to update Call GeoPixel button state
                const radioButtons = document.querySelectorAll('input[name="vis"]');
                radioButtons.forEach(radio => {
                    radio.addEventListener('change', function() {
                        // Small delay to ensure the view has switched before updating button state
                        setTimeout(() => {
                            if (window.runPodManager) {
                                console.log('Radio button changed, updating Call GeoPixel button state...');
                                
                                // Check if initialization is complete
                                const callGeoPixelBtn = document.getElementById('screenMap');
                                const initializationComplete = callGeoPixelBtn?.getAttribute('data-initialization-complete') === 'true';
                                
                                if (initializationComplete) {
                                    console.log('Initialization complete, updating button state based on radio selection');
                                    window.runPodManager.updateCallGeoPixelButtonState();
                                } else {
                                    console.log('Initialization not complete, keeping button disabled');
                                    // Ensure button stays disabled
                                    if (callGeoPixelBtn) {
                                        callGeoPixelBtn.disabled = true;
                                        callGeoPixelBtn.classList.remove('enabled');
                                        callGeoPixelBtn.classList.add('disabled-button');
                                    }
                                }
                            }
                        }, 50);
                    });
                });
            }, 100);
        });
    </script>
    
    <script defer src="{{ url_for('static', filename='js/main.js') }}" type="module"></script>

</body>

</html>